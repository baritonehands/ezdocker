{"version":3,"sources":["ezdocker.js"],"names":[],"mappings":"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","file":"ezdocker.js","sourcesContent":["import _ from 'lodash';\nimport { argv } from 'yargs';\nimport chalk from 'chalk';\nimport Docker from 'dockerode';\nimport moment from 'moment';\nimport stream from 'stream';\nimport TarUtils from './tar-utils';\n\n/**\n * Builder pattern for building up images names following the convention: `REGISTRY[:PORT]/USER/REPO[:TAG]`.\n */\nclass NameBuilder {\n\n  /**\n   * Constructor\n   *\n   * @param {EZDocker} ezdocker\n   */\n  constructor(ezdocker) {\n    this._ezdocker = ezdocker;\n\n    this._registry = undefined;\n    this._port = undefined;\n    this._user = undefined;\n    this._repo = undefined;\n    this._tag = undefined;\n  }\n\n  /**\n   * @param {String} registry\n   * @return {NameBuilder} this\n   */\n  registry(registry) {\n    this._registry = registry;\n    return this;\n  }\n\n  /**\n   * @param {String} port\n   * @return {NameBuilder} this\n   */\n  port(port) {\n    this._port = port;\n    return this;\n  }\n\n  /**\n   * @param {String} user\n   * @return {NameBuilder} this\n   */\n  user(user) {\n    this._user = user;\n    return this;\n  }\n\n  /**\n   * @param {String} repo\n   * @return {NameBuilder} this\n   */\n  repo(repo) {\n    this._repo = repo;\n    return this;\n  }\n\n  /**\n   * @param {String} tag\n   * @return {NameBuilder} this\n   */\n  tag(tag) {\n    this._tag = tag;\n    return this;\n  }\n\n  /**\n   * Get the short name (excluding tag) following the convention: `REGISTRY[:PORT]/USER/REPO`\n   *\n   * @return {String} the short name\n   */\n  getShortName() {\n    let name = this._registry;\n    if (this._port) {\n      name += ':' + this._port;\n    }\n    name += `/${this._user}/${this._repo}`;\n\n    return name;\n  }\n\n  /**\n   * Get the full name (indluding tag) following the convention: `REGISTRY[:PORT]/USER/REPO[:TAG]`\n   *\n   * @return {String} the short name\n   */\n  getFullName() {\n    return `${this.getShortName()}:${this._tag}`;\n  }\n}\n\n/**\n * Builder pattern for creating images.\n */\nclass ImageBuilder extends NameBuilder {\n\n  /**\n   * Constructor\n   *\n   * @param {EZDocker} ezdocker\n   */\n  constructor(ezdocker) {\n    super(ezdocker);\n\n    this._paths = {};\n  }\n\n  /**\n   * Add a path with an optional mapping onto a sub-folder path for a destination. These folders will be recursively\n   * passed to the Docker image according to this mapping.  By default, the dest will be '.' meaning that it is the\n   * root folder from the perspective of the docker build process. The Dockerfile should always be put into this\n   * default root ('.') folder.\n   *\n   * @param {String} src the source folder\n   * @param {String} [dest='.'] the destination folder\n   * @return {ImageBuilder} this\n   */\n  addPath(src, dest = '.') {\n    this._paths[src] = dest;\n    return this;\n  }\n\n  /**\n   * Actually build the image using the paths and naming as recorded with this builder. This will actually\n   * send the mapped folders (and the Dockerfile contained within) to the docker host for building. This returns\n   * a Promise that will resolve when the build finishes or reject with the associated error on failure.\n   *\n   * @return {Promise<null,Error>} a promise that will resolve when the build finishes\n   */\n  build() {\n    return this._ezdocker._buildImage(this);\n  }\n}\n\n/**\n * Builder pattern for removing images. Note that tags are not required (and ignored).\n */\nclass ImageRemover extends NameBuilder {\n\n  /**\n   * Constructor\n   *\n   * @param {EZDocker} ezdocker\n   */\n  constructor(ezdocker) {\n    super(ezdocker);\n  }\n\n  /**\n   * Remove images that match the built name from the docker host.\n   *\n   * @return {Promise<null,Error>} a promise that will resolve when the removal finishes\n   */\n  remove() {\n    return this._ezdocker._removeImages(this);\n  }\n}\n\n/**\n * Builder pattern for pushing images. Note that tags are not required (and ignored).\n */\nclass ImagePusher extends NameBuilder {\n\n  /**\n   * Constructor\n   *\n   * @param {EZDocker} ezdocker\n   */\n  constructor(ezdocker) {\n    super(ezdocker);\n  }\n\n  /**\n   * Push images from the docker host to the named docker registry.\n   *\n   * @return {Promise<null,Error>} a promise that will resolve when the pushing finishes\n   */\n  push() {\n    return this._ezdocker._pushImages(this);\n  }\n}\n\n/**\n * EZDocker provides easy to use access to builder-pattern classes for building images, removing images and pushing\n * images to a docker registry. See the README for more information on how to use.\n */\nclass EZDocker {\n\n  /**\n   * Creates a EZDocker using command line arguments.\n   *\n   * @param {{}} [args=argv] the arguments that default to those from yargs.argv\n   *\n   * @return {EZDocker}\n   */\n  static createFromArgs(args = argv) {\n    return new EZDocker(args.docker);\n  }\n\n  /**\n   * Constructs a new EZDocker. See the README for valid connectionOpts. `docker` and `tarUtils` are only for use\n   * in unit-testing to inject mock dependencies.\n   *\n   * @param {Map<String,String>} connectionOpts configures the connection method to\n   * @param {Docker} [docker] used for dependency injection, if set, connectionOpts are ignored\n   * @param {TarUtils} [tarUtils=new TarUtils()] used for dependency injection\n   */\n  constructor(connectionOpts, docker, tarUtils = new TarUtils()) {\n    this._docker = docker || new Docker(connectionOpts);\n    this._tarUtils = tarUtils;\n  }\n\n  /**\n   * Creates a new image builder.\n   *\n   * @return {ImageBuilder}\n   */\n  imageBuilder() {\n    return new ImageBuilder(this);\n  }\n\n  /**\n   * Creates a new image remover.\n   *\n   * @return {ImageRemover}\n   */\n  imageRemover() {\n    return new ImageRemover(this);\n  }\n\n  /**\n   * Creates a new image pusher.\n   *\n   * @return {ImagePusher}\n   */\n  imagePusher() {\n    return new ImagePusher(this);\n  }\n\n  /**\n   * Build the image. This creates a single tar stream of all the paths and sends it to the docker host for building.\n   *\n   * @param {ImageBuilder} imageBuilder the image builder\n   * @return {Promise<null,Error>}\n   * @private\n   */\n  _buildImage(imageBuilder) {\n    return this._tarUtils.all(imageBuilder._paths)\n      .then((stream) => {\n        return new Promise((resolve, reject) => {\n          this._docker.buildImage(stream, {t: imageBuilder.getFullName()}, (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              response.pipe(stream_parser);\n              response.on('end', () => {\n                resolve();\n              });\n            }\n          });\n        });\n      });\n  }\n\n  /**\n   * Remove images.\n   *\n   * @param {ImageRemover} imageRemover the image remover\n   * @return {Promise<null,Error>}\n   * @private\n   */\n  _removeImages(imageRemover) {\n    return this._listImages(imageRemover.getShortName())\n      .then((images) => {\n        return Promise.all(_.map(images, (imageInfo) => {\n          return this.removeImage(imageInfo.Id);\n        }));\n      });\n  }\n\n  /**\n   * Lists images on the docker host by short name (no tag).\n   *\n   * @param {String} shortName the short name\n   * @return {Promise<[{}],Error>} a promise that resolves with an array of maps containing image info\n   * @private\n   */\n  _listImages(shortName) {\n    return new Promise((resolve, reject) => {\n      this._docker.listImages({filter: shortName}, (error, response) => {\n        if (error) {\n          Log.error('Listing Docker Images Failed: ' + error.message);\n          reject(error);\n        } else {\n          resolve(response);\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove a single image by hex id (short or long).\n   *\n   * @param {String} id hex id for the image\n   * @return {Promise<null,Error>} promise that resolves after the image has been removed\n   */\n  removeImage(id) {\n    return new Promise((resolve, reject) => {\n      this._docker.getImage(id).remove({}, (error, response) => {\n        if (error) {\n          if (error.statusCode == 404) {\n            Log.info('No docker images to remove.');\n            resolve();\n          } else {\n            Log.error('Removing Docker Image Failed: ' + error.message);\n            reject(error);\n          }\n        } else {\n          Log.info('Removing Image ' + id);\n          _.forEach(response, (step) => {\n            _.forEach(step, (target, action) => {\n              Log.info('  ' + action + ' ' + target);\n            });\n          });\n          resolve();\n        }\n      });\n    });\n  };\n\n  /**\n   * Push images.\n   *\n   * @param {ImagePusher} imagePusher the image pusher\n   * @return {Promise<null,Error>}\n   * @private\n   */\n  _pushImages(imagePusher) {\n    return new Promise((resolve, reject) => {\n      this._docker.getImage(imagePusher.getShortName()).push({}, (error, response) => {\n        if (error) {\n          Log.error('Pushing Docker Image(s) Failed: ' + error.message);\n          reject(error);\n        } else {\n          response.pipe(stream_parser);\n          response.on('end', () => {\n            resolve();\n          });\n        }\n      });\n    });\n  }\n}\n\n/**\n * Writable output stream that reads and transposes messages from the docker host into readable messages\n * that get printed out to STDOUT.\n *\n * @type {stream.Writable}\n */\nconst stream_parser = new stream.Writable({\n  write: function (chunk, encoding, next) {\n    var data = JSON.parse(chunk.toString());\n\n    if (data.stream) {\n      data.stream = data.stream.replace(/\\n$/, '');\n      Log.info(data.stream);\n    } else {\n      Log.info(chalk.blue('RAW: ') + JSON.stringify(data));\n    }\n\n    next();\n  }\n});\n\n/**\n * Log writing system.\n */\nclass Log {\n\n  /**\n   * Log a message with blue (Docker) prefix. The message will not be chalked automatically.\n   *\n   * @param msg the message\n   */\n  static info(msg) {\n    Log._log(chalk.blue('(Docker) ') + msg);\n  }\n\n  /**\n   * Log a message with red (Docker) prefix. The msg will also be red.\n   *\n   * @param msg the message\n   */\n  static error(msg) {\n    Log._log(chalk.red('(Docker) ' + msg));\n  }\n\n  /**\n   * Log the msg and prepend it with a timestamp in the format of [HH:mm:ss].\n   *\n   * @param msg the message\n   * @private\n   */\n  static _log(msg) {\n    let time = moment().format('HH:mm:ss');\n    console.log(`[${chalk.gray(time)}] ${msg}`);\n  }\n}\n\nexport { NameBuilder, ImageBuilder, ImageRemover, ImagePusher, EZDocker, Log, stream_parser };\nexport default EZDocker;"],"sourceRoot":"/source/"}