{"version":3,"sources":["tar-utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiBM;;;;;;;;;;;AAUJ,WAVI,QAUJ,GAAkE;QAAtD,0FAAsD;;QAA1C,wFAA0C;;QAAhC,4FAAgC;;QAApB,iEAAW,uBAAS;;0BAV9D,UAU8D;;AAChE,SAAK,IAAL,GAAY,IAAZ,CADgE;AAEhE,SAAK,GAAL,GAAW,GAAX,CAFgE;AAGhE,SAAK,QAAL,GAAgB,QAAhB,CAHgE;AAIhE,SAAK,IAAL,GAAY,IAAZ,CAJgE;GAAlE;;;;;;;;;eAVI;;wBAuBA,SAAS;;;AACX,UAAI,OAAO,KAAK,UAAL,EAAP,CADO;AAEX,WAAK,SAAL,CAAe,IAAf,EAFW;;AAIX,aAAO,KAAK,OAAL,CAAa,OAAb,EAAsB,IAAtB,EACJ,IADI,CACC,YAAM;AAAE,eAAO,MAAK,IAAL,CAAU,IAAV,CAAe,IAAf,CAAP,CAAF;OAAN,CADR,CAJW;;;;;;;;;;;iCAaA;AACX,aAAO,KAAK,GAAL,CAAS,MAAT,KAAoB,cAApB,GAAqC,KAAK,KAAL,CAAW,KAAK,MAAL,KAAgB,KAAhB,CAAhD,CADI;;;;;;;;;;;;;4BAWL,SAAS,SAAS;;;AACxB,UAAI,WAAW,iBAAE,GAAF,CAAM,OAAN,EAAe,UAAC,MAAD,EAAS,MAAT,EAAoB;AAChD,eAAO,OAAK,IAAL,CAAU,MAAV,EAAkB,UAAU,GAAV,GAAgB,MAAhB,CAAzB,CADgD;OAApB,CAA1B,CADoB;;AAKxB,aAAO,QAAQ,GAAR,CAAY,QAAZ,CAAP,CALwB;;;;;;;;;;;;;yBAerB,MAAM,IAAI;;;AACb,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,YAAI,UAAU,OAAK,IAAL,CAAU,OAAV,CAAkB,EAAlB,CAAV,CADkC;AAEtC,gBAAQ,EAAR,CAAW,QAAX,EAAqB,YAAM;AAAE,oBAAF;SAAN,CAArB,CAFsC;AAGtC,eAAK,IAAL,CAAU,IAAV,CAAe,IAAf,EAAqB,IAArB,CAA0B,OAA1B,EAHsC;OAArB,CAAnB,CADa;;;;;;;;;;;8BAaL,QAAQ;;;AAChB,UAAI,iBAAiB,KAAjB,CADY;;AAGhB,WAAK,QAAL,CAAc,EAAd,CAAiB,YAAjB,EAA+B,YAAM;AACnC,YAAI,CAAC,cAAD,EAAiB;AACnB,iBAAK,IAAL,CAAU,MAAV,EADmB;AAEnB,2BAAiB,IAAjB,CAFmB;SAArB;OAD6B,CAA/B,CAHgB;;;;SA3Ed;;;kBAuFS","file":"tar-utils.js","sourcesContent":["import _ from 'lodash';\nimport os from 'os';\nimport del from 'del';\nimport tar from 'tar-fs';\n\n/**\n * Utilities for generating a more complex tar stream. Specifically, this allows for putting multiple\n * source folders into a single stream with potential custom mappings. This uses a temporary file for\n * intermediate staging which will be automatically cleaned up on process exit.\n *\n * @example\n * let tarUtils = new TarUtils();\n * let stream = tarUtils.all({\n *   '/fully/qualified/path' : '.',\n *   'relative/path' : 'subfolder'\n * });\n */\nclass TarUtils {\n\n  /**\n   * Constructor with optional injection of dependencies for purposes of testing.\n   *\n   * @param {function} [_del=del]\n   * @param {os} [_os=os]\n   * @param {tar} [_tar=tar]\n   * @param {process} [_process=process]\n   */\n  constructor(_del = del, _os = os, _tar = tar, _process = process) {\n    this._del = _del;\n    this._os = _os;\n    this._process = _process;\n    this._tar = _tar;\n  }\n\n  /**\n   * Generate a single tar stream that contains multiple inputs that can be mapped to relative paths.\n   *\n   * @param {{String, String}} mapping a map of source folders to target relative paths\n   * @return {Promise<stream.Readable, Error>} a promise that resolves with the generated combined stream\n   */\n  all(mapping) {\n    var temp = this.tempFolder();\n    this.autoclean(temp);\n\n    return this.copyAll(mapping, temp)\n      .then(() => { return this._tar.pack(temp); });\n  }\n\n  /**\n   * Generate a path for a temporary file that is appropriate for the current OS.\n   *\n   * @return {string} full-qualified folder path\n   */\n  tempFolder() {\n    return this._os.tmpdir() + '/tar-utils__' + Math.floor(Math.random() * 10000);\n  }\n\n  /**\n   * Recursively copy files from the source mapping onto the destination baseDir applying the additional subfoldering.\n   *\n   * @param {Map<String, String>} mapping a map of source folders to target relative paths\n   * @param {String} baseDir the base output folder where all of the sources should be copied to\n   * @return {Promise} a promise that resolves when all files have been copied\n   */\n  copyAll(mapping, baseDir) {\n    var promises = _.map(mapping, (subDir, source) => {\n      return this.copy(source, baseDir + '/' + subDir);\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Copy files from the source folder to the destination folder.\n   *\n   * @param {String} from the source folder\n   * @param {String} to the destination folder\n   * @return {Promise} a promise that resolves when all files have been copied\n   */\n  copy(from, to) {\n    return new Promise((resolve, reject) => {\n      var extract = this._tar.extract(to);\n      extract.on('finish', () => { resolve(); });\n      this._tar.pack(from).pipe(extract);\n    });\n  }\n\n  /**\n   * Schedule the given folder to be automatically cleaned up when the JavaScript process finishes running.\n   *\n   * @param {String} folder the folder to cleanup\n   */\n  autoclean(folder) {\n    var cleanupStarted = false;\n\n    this._process.on('beforeExit', () => {\n      if (!cleanupStarted) {\n        this._del(folder);\n        cleanupStarted = true;\n      }\n    });\n  }\n}\n\nexport default TarUtils;\n"],"sourceRoot":"/source/"}